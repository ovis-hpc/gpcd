/******************************************************************************
 * COPYRIGHT CRAY INC. ar_fma_structs.h
 * FILE: ar_fma_structs.h
 * Created by v2h.c on Wed Oct  8 14:38:59 2014
 ******************************************************************************/

#ifndef _AR_FMA_STRUCTS_H_
#define _AR_FMA_STRUCTS_H_

/*
 *  ARIES FMA STRUCTURES
 */
typedef union ar_nic_fma_cfg_desc_sfma_desc {
    struct {
        // QW0 - OVERLOADED FIELDS
        union {
            struct {
                uint64_t base_offset              :58;	/* This field is used in computing the target Network Logical Address */
                uint64_t get_launch               : 1;	/* This descriptor field is used to store the FMA_LAUNCH_GET field written to the FMA_LAUNCH doorbell */
                uint64_t wc                       : 1;	/* Write combining enable */
                uint64_t rc                       : 3;	/* Routing ControlSpecifies constraints on how the packets of the transaction are routed through the network */
                uint64_t fma_en                   : 1;	/* Enable descriptorOperations dependent on values configured in this descriptor will not be performed unless this field is set to 1 */
            };
            struct {
                uint64_t global_offset            :58;	/* This descriptor field is also used to store the FMA_LAUNCH_GLOBAL_OFFSET field written to the FMA_LAUNCH doorbell */
                uint64_t undefine_q0_f1_63_58     : 6;	/* undefined */
            };
            struct {
                uint64_t status_wd_offset         :58;	/* This field is used in determining the offset in the target memory domain at which the status word will be written and in determining the target PE to which the status word will be written */
                uint64_t undefine_q0_f2_63_58     : 6;	/* undefined */
            };
        };
        // QW1
        uint64_t fma_op                   : 7;	/* Operation to perform (e */
        uint64_t reserved_71              : 1;	/* Reserved for potential future expansion of the FMA_OP field */
        uint64_t pe_mask_mode             : 3;	/* Specifies location of the 18 bit PE field in the sum of the Base Offset and window offset */
        uint64_t reserved_75              : 1;	/* Register bits exist, but not used for SFMA */
        uint64_t reserved_79_76           : 4;	/*  */
        uint64_t reserved_90_80           :11;	/* Register bits exist, but not used for SFMA */
        uint64_t reserved_91              : 1;	/*  */
        uint64_t reserved_97_92           : 6;	/* Register bits exist, but not used for SFMA */
        uint64_t reserved_99_98           : 2;	/*  */
        uint64_t reserved_101_100         : 2;	/* Register bits exist, but not used for SFMA */
        uint64_t loc_mdh                  :12;	/* Local Memory Domain HandleFor SFMA this is only used for Get and Fetching AMO requests */
        uint64_t reserved_114             : 1;	/* Reserved for future increase in MDH size */
        uint64_t rem_mdh                  :12;	/* Remote Memory Domain Handle */
        uint64_t reserved_127             : 1;	/* Reserved for future increase in MDH size */
        // QW2
        uint64_t npes                     :18;	/* This field is used when NTT_EN = 1 to indicate the number of PEs (destination endpoints) accessible through this descriptor */
        uint64_t pe_base                  :18;	/* This field is used when NTT_EN = 1 to indicate the base PE */
        uint64_t src_cqh                  :11;	/* Completion queue handle, used when a source side completion event is requested with the SEQCMP doorbell operation */
        uint64_t loc_ptag                 : 8;	/* Local memory protection tag used with FMA GET and fetching AMO operations */
        uint64_t rem_ptag                 : 8;	/* Destination Memory protection tag(Translated by the PTAG Translation Table (PTT) to a PKEY which is used in remote address translation at the destination endpoint */
        uint64_t ntt_en                   : 1;	/* Determines whether the Node Translation Table (NTT) (Section 1 */
        // QW3 - OVERLOADED FIELDS
        union {
            struct {
                uint64_t amo_oprnd1               ;	/* For SFMA this register is used for Fetching AMOs */
            };
            struct {
                uint64_t flag_data                ;	/* Optional flag data for message complete packets generated by writing the SEQCMP doorbell register */
            };
        };
        // QW4 - OVERLOADED FIELDS
        union {
            struct {
                uint64_t amo_oprnd2               ;	/* For SFMA this register is used for Fetching AMOs */
            };
            struct {
                uint64_t flag_data_offset         :40;	/* Offset within the remote memory domain specified by REM_MDH at which FLAG_DATA will be written for message complete requests generated by writing the SEQCMP doorbell */
                uint64_t undefine_q4_f1_319_296   :24;	/* undefined */
            };
        };
        // QW5
        uint64_t dest_cq_data             :48;	/* Destination side CQ dataThis field is used to indicate the SW_DATA value to be included in the optional sequence completion notification delivered at the destination endpoint */
        uint64_t reserved_383_368         :16;	/* Register bits exist, but not used for SFMA */
        // QW6
        uint64_t undefine_447_384         :64;	/* undefined */
        // QW7
        uint64_t base_offset_low_wren     : 1;	/* For SFMA, this bit controls access to bits [39:0] of BASE_OFFSET and of STATUS_WD_OFFSET */
        uint64_t base_offset_high_wren    : 1;	/* For SFMA, this bit controls access to bits [57:40] of BASE_OFFSET and of STATUS_WD_OFFSET */
        uint64_t rc_wren                  : 1;	/* This bit controls access to RC */
        uint64_t fma_en_wren              : 1;	/* This bit controls access to FMA_EN */
        uint64_t undefine_455_452         : 4;	/* undefined */
        uint64_t op_wren                  : 1;	/* This bit controls access to FMA_OP, BTE_OP, and CE_OP */
        uint64_t pe_mask_fpe_wren         : 1;	/* For SFMA, this bit controls access to PE_MASK_MODE */
        uint64_t enq_status_cqh_wren      : 1;	/* For FLBTE, this bit controls access to ENQ_STATUS_CQH_WREN */
        uint64_t nat_rdctrl_long_pkt_wren : 1;	/* For FLBTE, this bit controls access to the fields:NAT_EN, RD_RO, and RD_NO_SNOOP */
        uint64_t bte_chan_wren            : 1;	/* For FLBTE, this bit controls access to BTE_CHAN */
        uint64_t privileged_wren          : 1;	/* For FLBTE, this bit controls access to PRIVILEGED */
        uint64_t bte_fence_wren           : 1;	/* For FLBTE, this bit controls access to BTE_FENCE */
        uint64_t loc_mdh_wren             : 1;	/* For SFMA and FLBTE, this bit controls access to LOC_MDH */
        uint64_t rem_mdh_wren             : 1;	/* This bit controls access to REM_MDH */
        uint64_t undefine_471_465         : 7;	/* undefined */
        uint64_t npes_wren                : 1;	/* This bit controls access to NPES */
        uint64_t pe_base_wren             : 1;	/* This bit controls access to PE_BASE */
        uint64_t src_cqh_wren             : 1;	/* For SFMA and FLBTE, this bit controls access to SRC_CQH */
        uint64_t ptag_wren                : 1;	/* This bit controls access to LOC_PTAG and REM_PTAG */
        uint64_t ntt_en_wren              : 1;	/* This bit controls access to NTT_EN */
        uint64_t undefine_479_477         : 3;	/* undefined */
        uint64_t scratch_reg0_wren        : 1;	/* For SFMA, this bit controls access to AMO_OPRND1 and FLAG_DATA */
        uint64_t scratch_reg1_wren        : 1;	/* For SFMA, this bit controls access to AMO_OPRND2 and FLAG_DATA_OFFSET */
        uint64_t scratch_reg2_wren        : 1;	/* For SFMA, this bit controls access to DEST_CQ_DATA */
        uint64_t dla_cqh_wren             : 1;	/* Controls access to DLA_CQH */
        uint64_t dla_high_priority_wren   : 1;	/* Controls access to DLA_HIGH_PRIORITY */
        uint64_t dla_alloc_pr_wren        : 1;	/* Controls access to DLA_ALLOC_PR */
        uint64_t dla_alloc_cd_wren        : 1;	/* Controls access to DLA_ALLOC_CD */
        uint64_t wc_wren                  : 1;	/* Controls access to WC */
        uint64_t alloc_seq_id_dbell_wren  : 1;	/* This field allows use of the ALLOC_SEQ_ID doorbell */
        uint64_t seqcmp_dbell_wren        : 1;	/* This field allows use of the SEQCMP doorbell */
        uint64_t cq_write_dbell_wren      : 1;	/* This field allows use of the CQ_WRITE doorbell */
        uint64_t flbte_dbell_wren         : 1;	/* This field allows use of the FLBTE doorbell */
        uint64_t ce_dbell_wren            : 1;	/* This field allows use of the CE doorbell */
        uint64_t wr_status_dbell_wren     : 1;	/* This field allows use of the WR_STATUS doorbell */
        uint64_t fma_launch_dbell_wren    : 1;	/* This field allows use of the FMA_LAUNCH doorbell */
        uint64_t dla_marker_dbell_wren    : 1;	/* This field allows use of the DLA_MARKER doorbell */
        uint64_t status_wren              : 1;	/* This bit controls access to the defined fields in the STATUS word */
        uint64_t undefine_511_497         :15;	/* undefined */
        // QW8
        uint64_t status_interval          :10;	/* Sets DLA successful allocation CQE generation frequency */
        uint64_t reserved_523_522         : 2;	/*  */
        uint64_t block_id                 :20;	/* Used as CQE data */
        uint64_t credits_required         :14;	/* DLA credit allocation count */
        uint64_t reserved_571_558         :14;	/*  */
        uint64_t alloc_status_reset       : 1;	/* Clears pending DLA allocation status CQEs */
        uint64_t discard_reset            : 1;	/* This is part of the ALLOC_SEQID doorbell register */
        uint64_t dla_reissue              : 1;	/* This is part of the ALLOC_SEQID doorbell register */
        uint64_t transaction_start        : 1;	/* This is a the ALLOC_SEQID doorbell register */
        // QW9
        uint64_t cq_write                 :48;	/* This field is part of the CQ_WRITE doorbell register */
        uint64_t reserved_639_624         :16;	/* This is the CQ_WRITE doorbell register */
        // QW10
        uint64_t reserved_703_640         ;	/* The FLBTE doorbell register is not used with SFMA transactions */
        // QW11
        uint64_t reserved_767_704         ;	/* This is the CE leaf-join doorbell register */
        // QW12
        uint64_t wr_status_when           : 3;	/* This field is part of the WR_STATUS doorbell register */
        uint64_t reserved_831_771         :61;	/*  */
        // QW13
        uint64_t seqcmp_src_cq_data       :48;	/* This field is part of the SEQCMP doorbell register */
        uint64_t seqcmp_dla_dealloc       : 1;	/* This field is part of the SEQCMP doorbell register */
        uint64_t transaction_end          : 1;	/* This field is part of the SEQCMP doorbell register */
        uint64_t reserved_887_882         : 6;	/*  */
        uint64_t seqcmp_type              : 8;	/* This field is part of the SEQCMP doorbell register */
        // QW14
        uint64_t reserved_959_896         ;	/*  */
        // QW15
        uint64_t reserved_1023_960        ;	/*  */
        // QW16
        uint64_t status_wc                :16;	/* The status write count field is incremented by hardware each time a valid Put, non-fetching AMO, fetching AMO, CQWrite, MsgComplete, or CE leaf-join type request packet is issued and is decremented when the corresponding response has returned */
        uint64_t status_rc                :16;	/* The status read count field is incremented by hardware each time a valid Get or fetching AMO type request packet is issued and is decremented when the corresponding response has returned */
        uint64_t status_ssids_in_use      :10;	/* This field is incremented by hardware each time a Synchronization Sequence ID is allocated through a store to the ALLOC_SEQID doorbell and is decremented each time a Synchronization Sequence ID is de-allocated */
        uint64_t undefine_1071_1066       : 6;	/* undefined */
        uint64_t status_alloc_seqid_err   : 1;	/* This field is set to 1 by hardware when an action that normally results in a network request (request packet to TARB) is performed and a Synchronization Sequence ID is not allocated (See the ALLOC_SEQID doorbell) */
        uint64_t status_npes_err          : 1;	/* This field is set to 1 by hardware if an NPES violation occurs (see Section 1 */
        uint64_t status_sw_err            : 1;	/* This field is set to 1 by hardware if a request targeting this descriptor or targeting the FMA GET window or FMA PUT window associated with this descriptor is malformed */
        uint64_t status_hw_err            : 1;	/* This field is set to 1 by hardware if a request targeting this descriptor or targeting the FMA GET window or FMA PUT window associated with this descriptor has a hardware error */
        uint64_t status_priv_err          : 1;	/* This field is set to 1 by hardware if a request cannot be performed due to a lack of privilege */
        uint64_t undefine_1079_1077       : 3;	/* undefined */
        uint64_t status_launch0           : 1;	/* Indicates that the lower FMA launch doorbell has been written */
        uint64_t status_launch1           : 1;	/* Indicates that the upper FMA launch doorbell has been written */
        uint64_t undefine_1085_1082       : 4;	/* undefined */
        uint64_t status_trans_active      : 1;	/* Indicates that the descriptor is in use for a transaction */
        uint64_t status_done              : 1;	/* The fields in this register (STATUS) can be written to memory using the WR_STATUS doorbell register */
        // QW17
        uint64_t dla_cqh                  :11;	/* DLA completion queue handle, used as part of the ALLOC_SEQID and DLA_MARKER doorbells */
        uint64_t reserved_1099            : 1;	/*  */
        uint64_t dla_high_priority        : 1;	/* Sets controlled discard DLA allocation requests to high priority */
        uint64_t dla_alloc_pr             : 1;	/* Sets a DLA allocation request to persistent reservation */
        uint64_t dla_alloc_cd             : 1;	/* Sets a DLA allocation request to controlled discard */
        uint64_t reserved_1103            : 1;	/*  */
        uint64_t undefine_1151_1104       :48;	/* undefined */
        // QW18
        uint64_t undefine_1215_1152       :64;	/* undefined */
        // QW19
        uint64_t undefine_1279_1216       :64;	/* undefined */
        // QW20
        uint64_t undefine_1343_1280       :64;	/* undefined */
        // QW21
        uint64_t undefine_1407_1344       :64;	/* undefined */
        // QW22
        uint64_t undefine_1471_1408       :64;	/* undefined */
        // QW23
        uint64_t undefine_1535_1472       :64;	/* undefined */
        // QW24
        uint64_t fma_launch_global_offset :58;	/* Part of the FMA_LAUNCH doorbell together with offset 0xC8 */
        uint64_t fma_launch_get           : 1;	/* Part of the FMA_LAUNCH doorbell together with offset 0xC8 */
        uint64_t reserved_1599_1595       : 5;	/*  */
        // QW25
        uint64_t fma_launch_operand       ;	/* Part of the FMA_LAUNCH doorbell together with offset 0xC0 */
        // QW26
        uint64_t marker_id                :32;	/* This field is part of the DLA_MARKER doorbell register */
        uint64_t reserved_1711_1696       :16;	/*  */
        uint64_t dla_marker_dealloc       : 1;	/* This field is part of the DLA_MARKER doorbell register */
        uint64_t reserved_1727_1713       :15;	/*  */
    };
    uint64_t qwords[27];
} ar_nic_fma_cfg_desc_sfma_desc_t;

typedef union ar_nic_fma_cfg_desc_flbte_desc {
    struct {
        // QW0
        uint64_t rem_mem_offset           :40;	/* Starting offset in the remote memory domain (REM_MDH) */
        uint64_t logical_dest             :18;	/* Logical destination network endpoint id */
        uint64_t reserved_58              : 1;	/* Register bit exists, but not used for FLBTE */
        uint64_t wc                       : 1;	/* Write combining enable */
        uint64_t rc                       : 3;	/* Routing ControlSpecifies constraints on how the packets of the transaction are routed through the network */
        uint64_t fma_en                   : 1;	/* Enable descriptorAn FLBTE transaction is not launched on a write to the FLBTE doorbell register unless FMA_EN = 1 */
        // QW1
        uint64_t bte_op                   : 2;	/* The operation that is to be performed by the BTE transaction */
        uint64_t reserved_70_66           : 5;	/* Register bits exist, but not used for FLBTE */
        uint64_t reserved_71              : 1;	/* Reserved */
        uint64_t reserved_75_72           : 4;	/* Register bits exist, but not used for FLBTE */
        uint64_t undefine_79_76           : 4;	/* undefined */
        uint64_t enq_status_cqh           :11;	/* Handle of CQ used to report FLBTE enqueue status */
        uint64_t reserved_91              : 1;	/*  */
        uint64_t nat_en                   : 1;	/* Use network style address translation for Put / Send data buffer read requests issued by BTE */
        uint64_t rd_ro                    : 1;	/* If 1, relaxed ordering is allowed for Put / Send data buffer read requests issued to the local processor by BTE */
        uint64_t rd_no_snoop              : 1;	/* If 1, local processor cache coherency is not required for Put / Send data buffer read requests issued by BTE */
        uint64_t reserved_95              : 1;	/* Not used */
        uint64_t bte_chan                 : 2;	/* The BTE channel to which the FLBTE transaction will be enqueued */
        uint64_t reserved_99_98           : 2;	/* Reserved for future increase in BTE_CHAN size */
        uint64_t privileged               : 1;	/* If 1, the FLBTE transaction is considered by the BTE to be  */
        uint64_t bte_fence                : 1;	/* Fence inserted between end of processing of current FLBTE transaction and start of whichever BTE transaction is enqueued next */
        uint64_t loc_mdh                  :12;	/* Local Memory Domain Handle */
        uint64_t reserved_114             : 1;	/* Reserved for future increase in MDH size */
        uint64_t rem_mdh                  :12;	/* Remote Memory Domain Handle */
        uint64_t reserved_127             : 1;	/* Reserved for future increase in MDH size */
        // QW2
        uint64_t npes                     :18;	/* This field is only used when NTT_EN = 1, and is then used to indicate the number of PEs (destination endpoints) associated with the NTT group */
        uint64_t pe_base                  :18;	/* This field is used when NTT_EN = 1 to indicate the base PE */
        uint64_t src_cqh                  :11;	/* Completion queue handle for source side CQ events */
        uint64_t loc_ptag                 : 8;	/* Local memory protection tag */
        uint64_t rem_ptag                 : 8;	/* Destination Memory protection tag */
        uint64_t ntt_en                   : 1;	/* Determines whether the Node Translation Table (NTT) (Section 1 */
        // QW3 - OVERLOADED FIELDS
        union {
            struct {
                uint64_t loc_phys_addr            :48;	/* Local physical address */
                uint64_t reserved_255_240         :16;	/* Register bits exist, but not used for FLBTE */
            };
            struct {
                uint64_t loc_mem_offset           :40;	/* Starting offset in the local memory domain (LOC_MDH) */
                uint64_t undefine_q3_f1_255_232   :24;	/* undefined */
            };
        };
        // QW4
        uint64_t xfer_len                 :32;	/* The number of bytes to be transferred by the FLBTE transaction */
        uint64_t reserved_319_288         :32;	/* Register bits exist, but not used for FLBTE */
        // QW5
        uint64_t dest_user_data           ;	/* This field corresponds to the BTE TX descriptor DEST_USER_DATA field */
        // QW6
        uint64_t undefine_447_384         :64;	/* undefined */
        // QW7
        uint64_t privilege_mask           ;	/* This word of the FMA descriptor is used to disable the ability to modify other fields in this descriptor from FMA Descriptor User Access address space */
        // QW8
        uint64_t reserved_575_512         ;	/* The ALLOC_SEQID doorbell register is not used with FLBTE transactions */
        // QW9
        uint64_t reserved_639_576         ;	/* The CQ_WRITE doorbell register is not used with FLBTE transactions */
        // QW10
        uint64_t flbte_src_cq_data        :48;	/* This field is part of the FLBTE doorbell register */
        uint64_t reserved_699_688         :12;	/*  */
        uint64_t flbte_src_bte_cq_en      : 1;	/* This field is part of the FLBTE doorbell register */
        uint64_t flbte_src_ssid_cq_en     : 1;	/* This field is part of the FLBTE doorbell register */
        uint64_t flbte_bte_immediate      : 1;	/* This field is part of the FLBTE doorbell register */
        uint64_t flbte_rpt_enq_status     : 1;	/* This field is part of the FLBTE doorbell register */
        // QW11
        uint64_t reserved_767_704         ;	/* The CE doorbell register is not used with FLBTE transactions */
        // QW12
        uint64_t wr_status_when           : 3;	/* This field is part of the WR_STATUS doorbell register */
        uint64_t reserved_831_771         :61;	/*  */
        // QW13
        uint64_t reserved_895_832         ;	/* The SEQCMP doorbell register is not used with FLBTE transactions */
        // QW14
        uint64_t reserved_959_896         ;	/*  */
        // QW15
        uint64_t reserved_1023_960        ;	/*  */
        // QW16
        uint64_t status                   ;	/* The fields in this register (STATUS) are described in the SFMA version of the descriptor (offset 0x80) */
        // QW17
        uint64_t reserved_1151_1088       ;	/* Register bits exist, but not used for FLBTE */
        // QW18
        uint64_t undefine_1215_1152       :64;	/* undefined */
        // QW19
        uint64_t undefine_1279_1216       :64;	/* undefined */
        // QW20
        uint64_t undefine_1343_1280       :64;	/* undefined */
        // QW21
        uint64_t undefine_1407_1344       :64;	/* undefined */
        // QW22
        uint64_t undefine_1471_1408       :64;	/* undefined */
        // QW23
        uint64_t undefine_1535_1472       :64;	/* undefined */
        // QW24
        uint64_t reserved_1599_1536       ;	/* The FMA_LAUNCH doorbell register is not used with FLBTE transactions */
        // QW25
        uint64_t reserved_1663_1600       ;	/* The FMA_LAUNCH doorbell register is not used with FLBTE transactions */
        // QW26
        uint64_t reserved_1727_1664       ;	/* The DLA_MARKER doorbell register is not used with FLBTE transactions */
    };
    uint64_t qwords[27];
} ar_nic_fma_cfg_desc_flbte_desc_t;

typedef union ar_nic_fma_cfg_desc_ce_desc {
    struct {
        // QW0
        uint64_t scatter_offset           :40;	/* Starting offset in the memory domain identified by REM_MDH at which the scatter result of the reduction will be written */
        uint64_t logical_dest             :18;	/* Logical destination network endpoint id */
        uint64_t reserved_58              : 1;	/* Bit exists but is not used for CE operations */
        uint64_t reserved_59              : 1;	/* Bit exists but is not used for CE operations */
        uint64_t rc                       : 3;	/* Routing Control Controls the routing of the leaf-join request, through the network, to the destination endpoint containing the target CE */
        uint64_t fma_en                   : 1;	/* Enable descriptorA CE leaf-join request is not launched on a write to the CE doorbell register unless FMA_EN = 1 */
        // QW1
        uint64_t ce_op                    : 6;	/* The operation that is to be performed on the operands in the reduction */
        uint64_t reserved_70              : 1;	/* Register bits exist, but not used for CE leaf-join request */
        uint64_t reserved_71              : 1;	/* Reserved */
        uint64_t fp_exception             : 4;	/* Floating point exceptions present in the operand(s) being submitted to the reduction by this leaf-join request */
        uint64_t reserved_79_76           : 4;	/*  */
        uint64_t reserved_90_80           :11;	/* Register bits exist, but not used for CE leaf-join request */
        uint64_t reserved_91              : 1;	/*  */
        uint64_t reserved_97_92           : 6;	/* Register bits exist, but not used for CE leaf-join request */
        uint64_t reserved_99_98           : 2;	/*  */
        uint64_t reserved_113_100         :14;	/* Register bits exist, but not used for CE leaf-join request */
        uint64_t reserved_114             : 1;	/*  */
        uint64_t rem_mdh                  :12;	/* Identifies the memory domain that is to be used by the CE when returning the reduction scatter result */
        uint64_t reserved_127             : 1;	/* Reserved for future increase in MDH size */
        // QW2
        uint64_t npes                     :18;	/* This field is only used when NTT_EN = 1, and is then used to indicate the number of PEs (destination endpoints) associated with the NTT group */
        uint64_t pe_base                  :18;	/* This field is used only when NTT_EN = 1, and is then used to indicate the base endpoint ID */
        uint64_t reserved_182_164         :19;	/* Register bits exist, but not used for CE leaf-join request */
        uint64_t rem_ptag                 : 8;	/* Remote protection tag */
        uint64_t ntt_en                   : 1;	/* Determines whether the Node Translation Table (NTT) (Section 1 */
        // QW3
        uint64_t ce_oprnd1                ;	/* The first operand being submitted to the reduction by this leaf-join request */
        // QW4
        uint64_t ce_oprnd2                ;	/* The second operand being submitted to the reduction by this leaf-join request */
        // QW5
        uint64_t ce_id                    : 6;	/* Identifies the particular virtual CE at the destination endpoint that this leaf-join request is targeted to */
        uint64_t reserved_327_326         : 2;	/* Register bits exist, but not used for CE leaf-join request */
        uint64_t child_id                 : 6;	/* Identifies which child this leaf-join request corresponds to at the targeted virtual CE */
        uint64_t reserved_383_334         :50;	/* Register bits exist, but not used for CE leaf-join request */
        // QW6
        uint64_t undefine_447_384         :64;	/* undefined */
        // QW7
        uint64_t privilege_mask           ;	/* The use of the PRIVILEGE_MASK is described in detail in Section 6 */
        // QW8
        uint64_t alloc_seqid              ;	/* See the description of the TRANSACTION_START doorbell register in the SFMA version of the descriptor */
        // QW9
        uint64_t reserved_639_576         ;	/* The CQ_WRITE doorbell register is not used with CE leaf-join requests */
        // QW10
        uint64_t reserved_703_640         ;	/* The FLBTE doorbell register is not used with CE leaf-join requests */
        // QW11
        uint64_t cedb_reductn_id          :40;	/* This field is part of the CE doorbell register */
        uint64_t cedb_use_oprnd2          : 1;	/* This field, when set to 1, indicates that operand 2 should be included in this leaf-join request */
        uint64_t reserved_767_745         :23;	/* This field is the CE doorbell register */
        // QW12
        uint64_t wr_status_when           : 3;	/* This field is part of the WR_STATUS doorbell register */
        uint64_t reserved_831_771         :61;	/*  */
        // QW13
        uint64_t seqcmp                   ;	/* See the description of the SEQCMP doorbell register (offset 0x68) in the SFMA version of the descriptor */
        // QW14
        uint64_t reserved_959_896         ;	/*  */
        // QW15
        uint64_t reserved_1023_960        ;	/*  */
        // QW16
        uint64_t status                   ;	/* The register (STATUS) can be written to memory using the WR_STATUS doorbell register */
        // QW17
        uint64_t reserved_1151_1088       ;	/* Register bits exist, but not used for CE */
        // QW18
        uint64_t undefine_1215_1152       :64;	/* undefined */
        // QW19
        uint64_t undefine_1279_1216       :64;	/* undefined */
        // QW20
        uint64_t undefine_1343_1280       :64;	/* undefined */
        // QW21
        uint64_t undefine_1407_1344       :64;	/* undefined */
        // QW22
        uint64_t undefine_1471_1408       :64;	/* undefined */
        // QW23
        uint64_t undefine_1535_1472       :64;	/* undefined */
        // QW24
        uint64_t reserved_1599_1536       ;	/* The FMA_LAUNCH doorbell register is not used with CE leaf-join requests */
        // QW25
        uint64_t reserved_1663_1600       ;	/* The FMA_LAUNCH doorbell register is not used with CE leaf-join requests */
        // QW26
        uint64_t reserved_1727_1664       ;	/* The DLA_MARKER doorbell register is not used with CE transactions */
    };
    uint64_t qwords[27];
} ar_nic_fma_cfg_desc_ce_desc_t;

typedef union ar_nic_fma_err_flg_desc {
    struct {
        // QW0
        uint64_t diag_only                : 1;	/* Not written by hardware, software writable */
        uint64_t desc00_sbe               : 1;	/* Descriptor offset 0x00 single bit error */
        uint64_t desc00_mbe               : 1;	/* Descriptor offset 0x00 multiple bit error */
        uint64_t desc08_sbe               : 1;	/* Descriptor offset 0x08 single bit error */
        uint64_t desc08_mbe               : 1;	/* Descriptor offset 0x08 multiple bit error */
        uint64_t desc10_sbe               : 1;	/* Descriptor offset 0x10 single bit error */
        uint64_t desc10_mbe               : 1;	/* Descriptor offset 0x10 multiple bit error */
        uint64_t desc18_sbe               : 1;	/* Descriptor offset 0x18 single bit error */
        uint64_t desc18_mbe               : 1;	/* Descriptor offset 0x18 multiple bit error */
        uint64_t desc20_sbe               : 1;	/* Descriptor offset 0x20 single bit error */
        uint64_t desc20_mbe               : 1;	/* Descriptor offset 0x20 multiple bit error */
        uint64_t desc28_sbe               : 1;	/* Descriptor offset 0x28 single bit error */
        uint64_t desc28_mbe               : 1;	/* Descriptor offset 0x28 multiple bit error */
        uint64_t desc38_sbe               : 1;	/* Descriptor offset 0x38 single bit error */
        uint64_t desc38_mbe               : 1;	/* Descriptor offset 0x38 multiple bit error */
        uint64_t desc88_sbe               : 1;	/* Descriptor offset 0x88 single bit error */
        uint64_t desc88_mbe               : 1;	/* Descriptor offset 0x88 multiple bit error */
        uint64_t data0in_sbe              : 1;	/* Data flit in word 0 single bit error */
        uint64_t data0in_mbe              : 1;	/* Data flit in word 0 multiple bit error */
        uint64_t data1in_sbe              : 1;	/* Data flit in word 1 single bit error */
        uint64_t data1in_mbe              : 1;	/* Data flit in word 1 multiple bit error */
        uint64_t hdr_perr                 : 1;	/* Header parity error */
        uint64_t desc_db_wr_err           : 1;	/* Attempt to write a doorbell except for FMA_LAUNCH0 with a payload size that is not 8 bytes */
        uint64_t desc_wr_err              : 1;	/* Attempt to write a descriptor or to do a CQ RD INDEX update with a payload size that is not an 8-byte multiple */
        uint64_t pi_buf_overflow          : 1;	/* Processor interface input buffer overflow */
        uint64_t desc_enable_err          : 1;	/* Attempt to use a disabled descriptor */
        uint64_t ssid_allocid_err         : 1;	/* Allocate SSID attempt to already active sequence */
        uint64_t nopriv_err               : 1;	/* User attempt to write descriptor or doorbell without privilege to do so */
        uint64_t db_mbe_err               : 1;	/* Multi-bit error on doorbell write data */
        uint64_t pi_cmd_err               : 1;	/* Packet from PI that is not a PUT request */
        uint64_t ssid_inactive_err        : 1;	/* SSID not allocated and attempt to perform an operation that must be part of an active transaction */
        uint64_t pi_len_err               : 1;	/* PUT from PI that has no payload */
        uint64_t pi_addr_err              : 1;	/* Packet from PI that is not to an FMA address */
        uint64_t npes_err                 : 1;	/* Request generated address exceeded PE limit */
        uint64_t inv_com_err              : 1;	/* Invalid FMA_OP, FMA_GOP, or CE_OP */
        uint64_t put_len_err              : 1;	/* Non-fetching AMO with payload length inconsistent with FMA_OP */
        uint64_t get_len_err              : 1;	/* Get request that crosses remote cache line boundary or fetching-AMO response size inconsistent with FMA_GOP */
        uint64_t get_fr_err               : 1;	/* Get with flagged response that crosses local cache line boundary or with local address that is not 32-bit aligned */
        uint64_t addr_align_err           : 1;	/* A 64-bit two operand non-fetching AMO that is not 128-bit address aligned and not in AAX_OPRND_MODE */
        uint64_t fma_launch_err           : 1;	/* Re-write FMA_LAUNCH0 while FMA_LAUNCH0_STATUS bit is set, or re-write FMA_LAUNCH1 while FMA_LAUNCH1_STATUS bit is set */
        uint64_t pi_get_addr_err          : 1;	/* PUT to the FMA GET window that is not 8-byte aligned or is not an 8-byte multiple in length */
        uint64_t gcw_mbe_err              : 1;	/* Multi-bit error on GCW payload flit */
        uint64_t amo_byte_put_err         : 1;	/* Byte store from PI to PUT window with FMA_OP equal to an AMO */
        uint64_t pi_byte_put_err          : 1;	/* Byte put received from PI that is not to an FMA PUT window */
        uint64_t pi_pkt_err               : 1;	/* Packet received from PI with a non-zero LSTATUS */
        uint64_t sw_err                   : 1;	/* Software error detected, set whenever STATUS_SW_ERR is set */
        uint64_t undefine_63_46           :18;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_err_flg_desc_t;

typedef union ar_nic_fma_err_clr_desc {
    struct {
        // QW0
        uint64_t diag_only                : 1;	/* Not written by hardware, software writable */
        uint64_t desc00_sbe               : 1;	/* Descriptor offset 0x00 single bit error */
        uint64_t desc00_mbe               : 1;	/* Descriptor offset 0x00 multiple bit error */
        uint64_t desc08_sbe               : 1;	/* Descriptor offset 0x08 single bit error */
        uint64_t desc08_mbe               : 1;	/* Descriptor offset 0x08 multiple bit error */
        uint64_t desc10_sbe               : 1;	/* Descriptor offset 0x10 single bit error */
        uint64_t desc10_mbe               : 1;	/* Descriptor offset 0x10 multiple bit error */
        uint64_t desc18_sbe               : 1;	/* Descriptor offset 0x18 single bit error */
        uint64_t desc18_mbe               : 1;	/* Descriptor offset 0x18 multiple bit error */
        uint64_t desc20_sbe               : 1;	/* Descriptor offset 0x20 single bit error */
        uint64_t desc20_mbe               : 1;	/* Descriptor offset 0x20 multiple bit error */
        uint64_t desc28_sbe               : 1;	/* Descriptor offset 0x28 single bit error */
        uint64_t desc28_mbe               : 1;	/* Descriptor offset 0x28 multiple bit error */
        uint64_t desc38_sbe               : 1;	/* Descriptor offset 0x38 single bit error */
        uint64_t desc38_mbe               : 1;	/* Descriptor offset 0x38 multiple bit error */
        uint64_t desc88_sbe               : 1;	/* Descriptor offset 0x88 single bit error */
        uint64_t desc88_mbe               : 1;	/* Descriptor offset 0x88 multiple bit error */
        uint64_t data0in_sbe              : 1;	/* Data flit in word 0 single bit error */
        uint64_t data0in_mbe              : 1;	/* Data flit in word 0 multiple bit error */
        uint64_t data1in_sbe              : 1;	/* Data flit in word 1 single bit error */
        uint64_t data1in_mbe              : 1;	/* Data flit in word 1 multiple bit error */
        uint64_t hdr_perr                 : 1;	/* Header parity error */
        uint64_t desc_db_wr_err           : 1;	/* Attempt to write a doorbell except for FMA_LAUNCH0 with a payload size that is not 8 bytes */
        uint64_t desc_wr_err              : 1;	/* Attempt to write a descriptor or to do a CQ RD INDEX update with a payload size that is not an 8-byte multiple */
        uint64_t pi_buf_overflow          : 1;	/* Processor interface input buffer overflow */
        uint64_t desc_enable_err          : 1;	/* Attempt to use a disabled descriptor */
        uint64_t ssid_allocid_err         : 1;	/* Allocate SSID attempt to already active sequence */
        uint64_t nopriv_err               : 1;	/* User attempt to write descriptor or doorbell without privilege to do so */
        uint64_t db_mbe_err               : 1;	/* Multi-bit error on doorbell write data */
        uint64_t pi_cmd_err               : 1;	/* Packet from PI that is not a PUT request */
        uint64_t ssid_inactive_err        : 1;	/* SSID not allocated and attempt to perform an operation that must be part of an active transaction */
        uint64_t pi_len_err               : 1;	/* PUT from PI that has no payload */
        uint64_t pi_addr_err              : 1;	/* Packet from PI that is not to an FMA address */
        uint64_t npes_err                 : 1;	/* Request generated address exceeded PE limit */
        uint64_t inv_com_err              : 1;	/* Invalid FMA_OP, FMA_GOP, or CE_OP */
        uint64_t put_len_err              : 1;	/* Non-fetching AMO with payload length inconsistent with FMA_OP */
        uint64_t get_len_err              : 1;	/* Get request that crosses remote cache line boundary or fetching-AMO response size inconsistent with FMA_GOP */
        uint64_t get_fr_err               : 1;	/* Get with flagged response that crosses local cache line boundary or with local address that is not 32-bit aligned */
        uint64_t addr_align_err           : 1;	/* A 64-bit two operand non-fetching AMO that is not 128-bit address aligned and not in AAX_OPRND_MODE */
        uint64_t fma_launch_err           : 1;	/* Re-write FMA_LAUNCH0 while FMA_LAUNCH0_STATUS bit is set, or re-write FMA_LAUNCH1 while FMA_LAUNCH1_STATUS bit is set */
        uint64_t pi_get_addr_err          : 1;	/* PUT to the FMA GET window that is not 8-byte aligned or is not an 8-byte multiple in length */
        uint64_t gcw_mbe_err              : 1;	/* Multi-bit error on GCW payload flit */
        uint64_t amo_byte_put_err         : 1;	/* Byte store from PI to PUT window with FMA_OP equal to an AMO */
        uint64_t pi_byte_put_err          : 1;	/* Byte put received from PI that is not to an FMA PUT window */
        uint64_t pi_pkt_err               : 1;	/* Packet received from PI with a non-zero LSTATUS */
        uint64_t sw_err                   : 1;	/* Software error detected, set whenever STATUS_SW_ERR is set */
        uint64_t undefine_63_46           :18;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_err_clr_desc_t;

typedef union ar_nic_fma_err_hss_msk_desc {
    struct {
        // QW0
        uint64_t diag_only                : 1;	/* 0:0 */
        uint64_t desc00_sbe               : 1;	/* 1:1 */
        uint64_t desc00_mbe               : 1;	/* 2:2 */
        uint64_t desc08_sbe               : 1;	/* 3:3 */
        uint64_t desc08_mbe               : 1;	/* 4:4 */
        uint64_t desc10_sbe               : 1;	/* 5:5 */
        uint64_t desc10_mbe               : 1;	/* 6:6 */
        uint64_t desc18_sbe               : 1;	/* 7:7 */
        uint64_t desc18_mbe               : 1;	/* 8:8 */
        uint64_t desc20_sbe               : 1;	/* 9:9 */
        uint64_t desc20_mbe               : 1;	/* 10:10 */
        uint64_t desc28_sbe               : 1;	/* 11:11 */
        uint64_t desc28_mbe               : 1;	/* 12:12 */
        uint64_t desc38_sbe               : 1;	/* 13:13 */
        uint64_t desc38_mbe               : 1;	/* 14:14 */
        uint64_t desc88_sbe               : 1;	/* 15:15 */
        uint64_t desc88_mbe               : 1;	/* 16:16 */
        uint64_t data0in_sbe              : 1;	/* 17:17 */
        uint64_t data0in_mbe              : 1;	/* 18:18 */
        uint64_t data1in_sbe              : 1;	/* 19:19 */
        uint64_t data1in_mbe              : 1;	/* 20:20 */
        uint64_t hdr_perr                 : 1;	/* 21:21 */
        uint64_t desc_db_wr_err           : 1;	/* 22:22 */
        uint64_t desc_wr_err              : 1;	/* 23:23 */
        uint64_t pi_buf_overflow          : 1;	/* 24:24 */
        uint64_t desc_enable_err          : 1;	/* 25:25 */
        uint64_t ssid_allocid_err         : 1;	/* 26:26 */
        uint64_t nopriv_err               : 1;	/* 27:27 */
        uint64_t db_mbe_err               : 1;	/* 28:28 */
        uint64_t pi_cmd_err               : 1;	/* 29:29 */
        uint64_t ssid_inactive_err        : 1;	/* 30:30 */
        uint64_t pi_len_err               : 1;	/* 31:31 */
        uint64_t pi_addr_err              : 1;	/* 32:32 */
        uint64_t npes_err                 : 1;	/* 33:33 */
        uint64_t inv_com_err              : 1;	/* 34:34 */
        uint64_t put_len_err              : 1;	/* 35:35 */
        uint64_t get_len_err              : 1;	/* 36:36 */
        uint64_t get_fr_err               : 1;	/* 37:37 */
        uint64_t addr_align_err           : 1;	/* 38:38 */
        uint64_t fma_launch_err           : 1;	/* 39:39 */
        uint64_t pi_get_addr_err          : 1;	/* 40:40 */
        uint64_t gcw_mbe_err              : 1;	/* 41:41 */
        uint64_t amo_byte_put_err         : 1;	/* 42:42 */
        uint64_t pi_byte_put_err          : 1;	/* 43:43 */
        uint64_t pi_pkt_err               : 1;	/* 44:44 */
        uint64_t sw_err                   : 1;	/* 45:45 */
        uint64_t undefine_63_46           :18;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_err_hss_msk_desc_t;

typedef union ar_nic_fma_err_os_msk_desc {
    struct {
        // QW0
        uint64_t diag_only                : 1;	/* 0:0 */
        uint64_t desc00_sbe               : 1;	/* 1:1 */
        uint64_t desc00_mbe               : 1;	/* 2:2 */
        uint64_t desc08_sbe               : 1;	/* 3:3 */
        uint64_t desc08_mbe               : 1;	/* 4:4 */
        uint64_t desc10_sbe               : 1;	/* 5:5 */
        uint64_t desc10_mbe               : 1;	/* 6:6 */
        uint64_t desc18_sbe               : 1;	/* 7:7 */
        uint64_t desc18_mbe               : 1;	/* 8:8 */
        uint64_t desc20_sbe               : 1;	/* 9:9 */
        uint64_t desc20_mbe               : 1;	/* 10:10 */
        uint64_t desc28_sbe               : 1;	/* 11:11 */
        uint64_t desc28_mbe               : 1;	/* 12:12 */
        uint64_t desc38_sbe               : 1;	/* 13:13 */
        uint64_t desc38_mbe               : 1;	/* 14:14 */
        uint64_t desc88_sbe               : 1;	/* 15:15 */
        uint64_t desc88_mbe               : 1;	/* 16:16 */
        uint64_t data0in_sbe              : 1;	/* 17:17 */
        uint64_t data0in_mbe              : 1;	/* 18:18 */
        uint64_t data1in_sbe              : 1;	/* 19:19 */
        uint64_t data1in_mbe              : 1;	/* 20:20 */
        uint64_t hdr_perr                 : 1;	/* 21:21 */
        uint64_t desc_db_wr_err           : 1;	/* 22:22 */
        uint64_t desc_wr_err              : 1;	/* 23:23 */
        uint64_t pi_buf_overflow          : 1;	/* 24:24 */
        uint64_t desc_enable_err          : 1;	/* 25:25 */
        uint64_t ssid_allocid_err         : 1;	/* 26:26 */
        uint64_t nopriv_err               : 1;	/* 27:27 */
        uint64_t db_mbe_err               : 1;	/* 28:28 */
        uint64_t pi_cmd_err               : 1;	/* 29:29 */
        uint64_t ssid_inactive_err        : 1;	/* 30:30 */
        uint64_t pi_len_err               : 1;	/* 31:31 */
        uint64_t pi_addr_err              : 1;	/* 32:32 */
        uint64_t npes_err                 : 1;	/* 33:33 */
        uint64_t inv_com_err              : 1;	/* 34:34 */
        uint64_t put_len_err              : 1;	/* 35:35 */
        uint64_t get_len_err              : 1;	/* 36:36 */
        uint64_t get_fr_err               : 1;	/* 37:37 */
        uint64_t addr_align_err           : 1;	/* 38:38 */
        uint64_t fma_launch_err           : 1;	/* 39:39 */
        uint64_t pi_get_addr_err          : 1;	/* 40:40 */
        uint64_t gcw_mbe_err              : 1;	/* 41:41 */
        uint64_t amo_byte_put_err         : 1;	/* 42:42 */
        uint64_t pi_byte_put_err          : 1;	/* 43:43 */
        uint64_t pi_pkt_err               : 1;	/* 44:44 */
        uint64_t sw_err                   : 1;	/* 45:45 */
        uint64_t undefine_63_46           :18;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_err_os_msk_desc_t;

typedef union ar_nic_fma_err_first_flg_desc {
    struct {
        // QW0
        uint64_t diag_only                : 1;	/* 0:0 */
        uint64_t desc00_sbe               : 1;	/* 1:1 */
        uint64_t desc00_mbe               : 1;	/* 2:2 */
        uint64_t desc08_sbe               : 1;	/* 3:3 */
        uint64_t desc08_mbe               : 1;	/* 4:4 */
        uint64_t desc10_sbe               : 1;	/* 5:5 */
        uint64_t desc10_mbe               : 1;	/* 6:6 */
        uint64_t desc18_sbe               : 1;	/* 7:7 */
        uint64_t desc18_mbe               : 1;	/* 8:8 */
        uint64_t desc20_sbe               : 1;	/* 9:9 */
        uint64_t desc20_mbe               : 1;	/* 10:10 */
        uint64_t desc28_sbe               : 1;	/* 11:11 */
        uint64_t desc28_mbe               : 1;	/* 12:12 */
        uint64_t desc38_sbe               : 1;	/* 13:13 */
        uint64_t desc38_mbe               : 1;	/* 14:14 */
        uint64_t desc88_sbe               : 1;	/* 15:15 */
        uint64_t desc88_mbe               : 1;	/* 16:16 */
        uint64_t data0in_sbe              : 1;	/* 17:17 */
        uint64_t data0in_mbe              : 1;	/* 18:18 */
        uint64_t data1in_sbe              : 1;	/* 19:19 */
        uint64_t data1in_mbe              : 1;	/* 20:20 */
        uint64_t hdr_perr                 : 1;	/* 21:21 */
        uint64_t desc_db_wr_err           : 1;	/* 22:22 */
        uint64_t desc_wr_err              : 1;	/* 23:23 */
        uint64_t pi_buf_overflow          : 1;	/* 24:24 */
        uint64_t desc_enable_err          : 1;	/* 25:25 */
        uint64_t ssid_allocid_err         : 1;	/* 26:26 */
        uint64_t nopriv_err               : 1;	/* 27:27 */
        uint64_t db_mbe_err               : 1;	/* 28:28 */
        uint64_t pi_cmd_err               : 1;	/* 29:29 */
        uint64_t ssid_inactive_err        : 1;	/* 30:30 */
        uint64_t pi_len_err               : 1;	/* 31:31 */
        uint64_t pi_addr_err              : 1;	/* 32:32 */
        uint64_t npes_err                 : 1;	/* 33:33 */
        uint64_t inv_com_err              : 1;	/* 34:34 */
        uint64_t put_len_err              : 1;	/* 35:35 */
        uint64_t get_len_err              : 1;	/* 36:36 */
        uint64_t get_fr_err               : 1;	/* 37:37 */
        uint64_t addr_align_err           : 1;	/* 38:38 */
        uint64_t fma_launch_err           : 1;	/* 39:39 */
        uint64_t pi_get_addr_err          : 1;	/* 40:40 */
        uint64_t gcw_mbe_err              : 1;	/* 41:41 */
        uint64_t amo_byte_put_err         : 1;	/* 42:42 */
        uint64_t pi_byte_put_err          : 1;	/* 43:43 */
        uint64_t pi_pkt_err               : 1;	/* 44:44 */
        uint64_t sw_err                   : 1;	/* 45:45 */
        uint64_t undefine_63_46           :18;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_err_first_flg_desc_t;

typedef union ar_nic_fma_err_info_ram0_desc {
    struct {
        // QW0
        uint64_t desc00_sbe_synd          : 8;	/* Descriptor ram 00 single bit error syndrome bits */
        uint64_t desc00_mbe_synd          : 8;	/* Descriptor ram 00 multiple bit error syndrome bits */
        uint64_t desc08_sbe_synd          : 8;	/* Descriptor ram 08 single bit error syndrome bits */
        uint64_t desc08_mbe_synd          : 8;	/* Descriptor ram 08 multiple bit error syndrome bits */
        uint64_t desc10_sbe_synd          : 8;	/* Descriptor ram 10 single bit error syndrome bits */
        uint64_t desc10_mbe_synd          : 8;	/* Descriptor ram 10 multiple bit error syndrome bits */
        uint64_t desc18_sbe_synd          : 8;	/* Descriptor ram 18 single bit error syndrome bits */
        uint64_t desc18_mbe_synd          : 8;	/* Descriptor ram 18 multiple bit error syndrome bits */
    };
    uint64_t qwords[1];
} ar_nic_fma_err_info_ram0_desc_t;

typedef union ar_nic_fma_err_info_ram1_desc {
    struct {
        // QW0
        uint64_t desc20_sbe_synd          : 8;	/* Descriptor ram 20 single bit error syndrome bits */
        uint64_t desc20_mbe_synd          : 8;	/* Descriptor ram 20 multiple bit error syndrome bits */
        uint64_t desc28_sbe_synd          : 8;	/* Descriptor ram 28 single bit error syndrome bits */
        uint64_t desc28_mbe_synd          : 8;	/* Descriptor ram 28 multiple bit error syndrome bits */
        uint64_t desc38_sbe_synd          : 8;	/* Descriptor ram 38 single bit error syndrome bits */
        uint64_t desc38_mbe_synd          : 8;	/* Descriptor ram 38 multiple bit error syndrome bits */
        uint64_t desc88_sbe_synd          : 8;	/* Descriptor ram 88 single bit error syndrome bits */
        uint64_t desc88_mbe_synd          : 8;	/* Descriptor ram 88 multiple bit error syndrome bits */
    };
    uint64_t qwords[1];
} ar_nic_fma_err_info_ram1_desc_t;

typedef union ar_nic_fma_err_info_data_desc {
    struct {
        // QW0
        uint64_t data0in_sbe_synd         : 8;	/* Data path in word 0 single bit error syndrome bits */
        uint64_t data0in_mbe_synd         : 8;	/* Data path in word 0 multiple bit error syndrome bits */
        uint64_t data1in_sbe_synd         : 8;	/* Data path in word 1 single bit error syndrome bits */
        uint64_t data1in_mbe_synd         : 8;	/* Data path in word 1 multiple bit error syndrome bits */
        uint64_t undefine_63_32           :32;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_err_info_data_desc_t;

typedef union ar_nic_fma_err_info_hdr_desc {
    struct {
        // QW0
        uint64_t perr0                    : 1;	/* Header parity error 0 */
        uint64_t perr1                    : 1;	/* Header parity error 1 */
        uint64_t perr2                    : 1;	/* Header parity error 2 */
        uint64_t perr3                    : 1;	/* Header parity error 3 */
        uint64_t undefine_63_4            :60;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_err_info_hdr_desc_t;

typedef union ar_nic_fma_dbg_errinj_ram_desc {
    struct {
        // QW0
        uint64_t enable                   : 1;	/* Enable Error Injection */
        uint64_t mode                     : 2;	/* Mode 0: Inject error once Mode 1: Inject error always Mode 2: Inject error once if address matches Mode 3: Inject error always if address matches */
        uint64_t triggered                : 1;	/*  */
        uint64_t desc00                   : 1;	/*  */
        uint64_t desc08                   : 1;	/* Inject errors into descriptor ram 08 */
        uint64_t desc10                   : 1;	/*  */
        uint64_t desc18                   : 1;	/* Inject errors into descriptor ram 18 */
        uint64_t desc20                   : 1;	/*  */
        uint64_t desc28                   : 1;	/* Inject errors into descriptor ram 28 */
        uint64_t desc38                   : 1;	/*  */
        uint64_t desc88                   : 1;	/*  */
        uint64_t undefine_15_12           : 4;	/* undefined */
        uint64_t checkbyte                : 8;	/*  */
        uint64_t undefine_31_24           : 8;	/* undefined */
        uint64_t address                  : 7;	/*  */
        uint64_t undefine_63_39           :25;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_dbg_errinj_ram_desc_t;

typedef union ar_nic_fma_dbg_errinj_pkt_desc {
    struct {
        // QW0
        uint64_t enable                   : 1;	/* Enable Error Injection */
        uint64_t mode                     : 1;	/* Mode 0: Inject error in Nth flit of one packet Mode 1: Inject error in Nth flit of all packets */
        uint64_t undefine_2_2             : 1;	/* undefined */
        uint64_t triggered                : 1;	/*  */
        uint64_t count                    : 6;	/*  */
        uint64_t tail                     : 1;	/*  */
        uint64_t undefine_11_11           : 1;	/* undefined */
        uint64_t parity                   : 4;	/*  */
        uint64_t checkbytelo              : 8;	/*  */
        uint64_t checkbyteup              : 8;	/*  */
        uint64_t undefine_63_32           :32;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_dbg_errinj_pkt_desc_t;

typedef union ar_nic_fma_cfg_credit_desc {
    struct {
        // QW0
        uint64_t dla_count                :16;	/* DLA FIFO maximum credit count */
        uint64_t tarb_int_count           : 5;	/*  */
        uint64_t undefine_23_21           : 3;	/* undefined */
        uint64_t aax_oprnd_mode           : 1;	/*  */
        uint64_t undefine_27_25           : 3;	/* undefined */
        uint64_t cq_count                 : 3;	/*  */
        uint64_t undefine_63_31           :33;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_cfg_credit_desc_t;

typedef union ar_nic_fma_err_info_pi_desc {
    struct {
        // QW0
        uint64_t lstatus                  : 6;	/* LSTATUS, valid when PI_PKT_ERR is set */
        uint64_t undefine_63_6            :58;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_err_info_pi_desc_t;

typedef union ar_nic_fma_err_info_sw_desc {
    struct {
        // QW0
        uint64_t undefine_1_0             : 2;	/* undefined */
        uint64_t address                  :46;	/* PI */
        uint64_t undefine_63_48           :16;	/* undefined */
    };
    uint64_t qwords[1];
} ar_nic_fma_err_info_sw_desc_t;


#endif
