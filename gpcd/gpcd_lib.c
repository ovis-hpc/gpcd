/*
 *  The Gemini Performance Counter driver.A
 *    Userspace interface library
 *
 *  Copyright 2011 Cray Inc. All Rights Reserved.
 *
 */

/* config file generated by top-level configure.in,
 * defines CRAY_GNI_ARCH_GEM and CRAY_GNI_ARCH_ARI. */
//#include <cray-gni-config.h>

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>

#include "gpcd_lib.h"

#define CRAY_GNI_ARCH_ARI 1

#if CRAY_GNI_ARCH_GEM
#include "gpcd_lib_gem_names.h"
#elif CRAY_GNI_ARCH_ARI
#include "gpcd_lib_ari_names.h"
#else
#error Only Gemini and Aries are supported
#endif


int gpcd_print_valid_nic_mmrs()
{
    const gpcd_mmr_desc_t   *mmrd;

    printf("Valid NIC MMRS for GPCD:\n");

    for (   mmrd = &valid_mmrs[0];
            mmrd->addr != 0;
            mmrd++) {
        printf("%-49s 0x%lx\n", mmrd->name, mmrd->addr);
    }
    return 0;
}

int gpcd_print_valid_tile_filtering_mmrs()
{
	const gpcd_mmr_desc_t *mmrd;

	for (	mmrd = &valid_tile_fpc_mmrs[0];
			mmrd->addr != 0;
			mmrd++) {
		printf("%-49s 0x%lx\n", mmrd->name, mmrd->addr);
	}

    return 0;
}

int gpcd_print_valid_tile_static_mmrs()
{
	const gpcd_mmr_desc_t *mmrd;

	for( 	mmrd = valid_tile_spc_mmrs;
			mmrd->addr != 0;
			mmrd++){
		printf("%-49s 0x%lx\n", mmrd->name, mmrd->addr);
	}

	return 0;
}

int gpcd_print_valid_tile_mmrs()
{
	gpcd_print_valid_tile_filtering_mmrs();

	printf("----------------\n");

	gpcd_print_valid_tile_static_mmrs();

	return 0;
}


int gpcd_read_mmr_val_byname(char* mmr_name, uint64_t *val, uint32_t nic_addr)
{
	const gpcd_mmr_desc_t	*mmrd;
	/*uint64_t	addr, retval;*/
	int error;

	if ((!mmr_name) || (!val)){
		printf("gpcd_read_mmr_val_byname 1\n");
		return -EINVAL;
	}

	error = strncmp(mmr_name, "GM_", 3);

	if (error != 0){
		printf("gpcd_read_mmr_val_byname 2\n");
		return -EINVAL;
	}

	for(mmrd = &valid_mmrs[0]; mmrd->addr != 0; mmrd++){
		error = strncmp(mmr_name, mmrd->name, 40);
		if (!error){
			break;
		}
	}

	if (mmrd->addr == 0){
		printf("gpcd_read_mmr_val_byname 3\n");
		return -ENOENT;
	}

	error = gpcd_read_mmr_val(mmrd, val, nic_addr);

	if(error){
		printf("gpcd_read_mmr_val_byname 4\n");
		return error;
	}

	return 0;
}

int gpcd_read_mmr_val(const gpcd_mmr_desc_t *mmrd, uint64_t *val,
					uint32_t nic_addr)
{
	int error, fd, req;
	gpcd_read_args_t req_data;
	uint64_t ret_data = 0;

	fd = open(GPCD_DEV_PATH, O_RDWR);
	if (fd < 1){
		printf("gpcd_read_mmr_val open failed.\n");
		return -ENOENT;
	}

	req = GPC_IOC_READ_REG;

	req_data.nic_addr = nic_addr;
	req_data.num_mmrs = 1;
	req_data.mmr_addrs = (uint64_t*)&mmrd->addr;
	req_data.mmr_data  = &ret_data;

	error = ioctl(fd, req, &req_data);

	if (error == -1){
		error = 0 - errno;

		close(fd);

		printf("gpcd_read_mmr_val ioctl error %d\n", error);
		return error;
	}

	*val = ret_data;

	close(fd);
	return 0;
}

int gpcd_write_mmr_val_byname(char* mmr_name, uint64_t *val, uint32_t nic_addr)
{
	const gpcd_mmr_desc_t *mmrd;
	int error;

	if ((!mmr_name) || (!val)){
		printf("gpcd_write_mmr_val_byname 1\n");
		return -EINVAL;
	}

	error = strncmp(mmr_name, "GM_", 3);

	if (error != 0){
		printf("gpcd_write_mmr_val_byname 2\n");
		return -EINVAL;
	}

	for (mmrd = &valid_mmrs[0]; mmrd->addr != 0; mmrd++){
		error = strncmp(mmr_name, mmrd->name, 40);
		if (!error){
			break;
		}
	}

	if (mmrd->addr == 0){
		printf("gpcd_write_mmr_val_byname 3\n");
		return -ENOENT;
	}

	error = gpcd_write_mmr_val(mmrd, val, nic_addr);

	if (error){
		printf("gpcd_write_mmr_val_byname 4\n");
		return error;
	}

	return 0;
}


int gpcd_write_mmr_val(const gpcd_mmr_desc_t *mmrd, uint64_t *val,
						uint32_t nic_addr)
{
	int error, fd;
	gpcd_write_args_t req_data;
	uint64_t data = *val;

	fd = open(GPCD_DEV_PATH, O_RDWR);
	if (fd < 1){
		printf("gpcd_write_mmr_val open failed.\n");
		return -ENOENT;
	}


	req_data.mmr_data  = &data;
	req_data.nic_addr  = nic_addr;
	req_data.num_mmrs  = 1;
	req_data.mmr_addrs = (uint64_t*)&mmrd->addr;

	error = ioctl(fd, GPC_IOC_WRITE_REG, &req_data);

	if (error == -1){
		error = 0 - errno;

		close(fd);

		printf("gpcd_write_mmr_val ioctl error %d\n", error);
		return error;
	}

	close(fd);
	return 0;
}

int gpcd_add_perms_entry(uint64_t    job_id,
    uint64_t    perms)
{
	int error, fd;
	gpcd_perms_t pdata;

	pdata.perms = perms;
	pdata.job_id = job_id;

	fd = open(GPCD_DEV_PATH, O_RDWR);
	if (fd < 1){
		printf("gpcd_add_perms_entry open failed.\n");
		return -ENOENT;
	}

	error = ioctl(fd, GPC_IOC_SET_PERMS, &pdata);

	if (error == -1){
		error = 0 - errno;
		close(fd);
		printf("gpcd_add_perms_entry ioctl error %d\n", error);
		return error;
	}

	close(fd);
	return 0;
}

/*must be root to disable perms checking.*/
int gpcd_disable_perms()
{
	int error, fd;

	fd = open(GPCD_DEV_PATH, O_RDWR);
	if (fd < 1){
		printf("gpcd_disable_perms open failed.\n");
		return -ENOENT;
	}

	error = ioctl(fd, GPC_IOC_IGNORE_PERMS, NULL);

	if (error == -1){
		error = 0 - errno;
		close(fd);
		printf("gpcd_disable_perms ioctl error %d\n", error);
		return error;
	}

	close(fd);
	return 0;
}

/* i == 1 : verbose on
 * i == -1: verbose off */
int gpcd_verbose_debug(int i)
{
	int error, fd;

	fd = open(GPCD_DEV_PATH, O_RDWR);
	if (fd < 1){
		printf("gpcd_verbose_debug open failed.\n");
		return -ENOENT;
	}

	error = ioctl(fd, GPC_IOC_VERBOSE, &i);

	if (error == -1){
		error = 0 - errno;
		close(fd);
		printf("gpcd_verbose_debug ioctl error %d\n", error);
		return error;
	}

	close(fd);
	return 0;
}


gpcd_context_t* gpcd_create_context(){
	gpcd_context_t *gcp;

	gcp = (gpcd_context_t*)malloc(sizeof(gpcd_context_t));
	if(gcp){
		gcp->list = NULL;
		gcp->count = 0;
		gcp->nic_addr = 0;
	}
	return gcp;
}


void gpcd_context_set_nic_addr(gpcd_context_t *cp, uint32_t nic_addr){
	cp->nic_addr = nic_addr;
}

int gpcd_remove_context(gpcd_context_t *context)
{
	gpcd_mmr_list_t *listp;

	if (!context)
		return -EINVAL;

	while(context->list){
		listp = context->list;
		context->list = listp->next;
		context->count--;
		free(listp);
	}

	if(context->count > 0){
		free(context);
		return -E2BIG;
	}

	free(context);
	return 0;
}

const gpcd_mmr_desc_t *gpcd_lookup_mmr_byname(char* mmr_name)
{
	const gpcd_mmr_desc_t *mmrp;
	int error;

	if (!mmr_name)
		return NULL;

	if (!gpcd_mmr_name_sane(mmr_name))
		return NULL;

	for (mmrp = &valid_mmrs[0]; mmrp->addr != 0; mmrp++){
		error = strncmp(mmr_name, mmrp->name, 40);
		if(error == 0)
			return mmrp;
	}

	for (mmrp = &valid_tile_fpc_mmrs[0]; mmrp->addr != 0; mmrp++){
		error = strncmp(mmr_name, mmrp->name, 40);
		if(error == 0)
			return mmrp;
	}

	for (mmrp = &valid_tile_spc_mmrs[0]; mmrp->addr != 0; mmrp++){
		error = strncmp(mmr_name, mmrp->name, 40);
		if(error == 0)
			return mmrp;
	}

	for (mmrp = &valid_tile_fpc_setup_mmrs[0]; mmrp->addr != 0; mmrp++){
		error = strncmp(mmr_name, mmrp->name, 40);
		if(error == 0)
			return mmrp;
	}



	return NULL;
}

int gpcd_context_add_mmr(gpcd_context_t *context, gpcd_mmr_desc_t *item)
{
	gpcd_mmr_list_t	*listp;

	if ((!context) || (!item))
		return -EINVAL;

	if (context->count >= 1024)
		return -E2BIG;

	listp = (gpcd_mmr_list_t*)malloc(sizeof(gpcd_mmr_list_t));
	if (!listp)
		return -ENOMEM;

	listp->item = item;
	listp->next = context->list;
	listp->value = 0;
	context->list = listp;
	context->count++;

	return 0;
}

gpcd_mmr_list_t* gpcd_context_find_list_byname(
	gpcd_context_t *context,
	char* mmr_name)
{
	gpcd_mmr_list_t *listp;
	int error;


	for (listp = context->list; listp != NULL; listp = listp->next){
		error = strncmp(mmr_name, listp->item->name, 40);
		if (error == 0) {
			return listp;
		}
	}

	return NULL;
}



int gpcd_context_remove_mmr(gpcd_context_t *context, gpcd_mmr_desc_t *item)
{
	gpcd_mmr_list_t	*listp1, *listp2;
	int i = 1;

	if ((!context) || (!item))
		return -EINVAL;
	if (!context->list)
		return -ENOENT;

	listp1 = context->list;
	if (listp1->item == item){
		context->list = listp1->next;
		context->count--;
		free(listp1);
		return 0;
	}

	while(listp1->next != NULL){
		if (i > context->count)
			return -E2BIG;

		listp2 = listp1;
		listp1 = listp1->next;
		i++;

		if (listp1->item == item){
			listp2->next = listp1->next;
			context->count--;
			free(listp1);
			return 0;
		}
	}

	return -ENOENT;
}

int gpcd_context_print(gpcd_context_t *context)
{
	gpcd_mmr_list_t *listp;
	int i=0;

	if (!context)
		return -EINVAL;
	if (!context->list)
		return -ENOENT;

	for(listp = context->list; listp; listp = listp->next)
		printf("GPCD Context print %3d : %s : %lu\n",
			i++, listp->item->name, listp->value);

	return 0;
}

int	gpcd_clone_context(
	gpcd_context_t	*in,
	gpcd_context_t  *out)
{
	gpcd_mmr_list_t	*mmrl;
	int	error;

	out = (gpcd_context_t*)malloc(sizeof(gpcd_context_t));
	if (!out)
		return -ENOMEM;
	out->count = 0;
	out->list = NULL;
	out->nic_addr = in->nic_addr;

	for(mmrl = in->list; mmrl; mmrl = mmrl->next){
		error = gpcd_context_add_mmr(out, mmrl->item);
		if (error){
			gpcd_remove_context(out);
			return -ENOMEM;
		}
	}

	return 0;
}

int gpcd_context_read_mmr_vals(gpcd_context_t *context)
{
	int i = 0, n = 0, fd, error;
	gpcd_read_args_t req_data;
	uint64_t *ret_data;
	uint64_t *addr_list = NULL;
	gpcd_mmr_list_t *listp1, *listp2;

	fd = open(GPCD_DEV_PATH, O_RDWR);
	if (fd < 1)
		return -ENOENT;

	ret_data = (uint64_t*)malloc(context->count * sizeof(uint64_t));
	if (!ret_data){
		error = -ENOMEM;
		goto out;
	}
	bzero((void*)ret_data,context->count * sizeof(uint64_t));

	addr_list = (uint64_t*)malloc(context->count * sizeof(uint64_t));
	if (!addr_list){
		error = -ENOMEM;
		goto out;
	}
	bzero((void*)addr_list,context->count * sizeof(uint64_t));

	req_data.mmr_data = ret_data;
	req_data.mmr_addrs = addr_list;
	req_data.num_mmrs = 0;
	req_data.nic_addr = context->nic_addr;

	listp2 = context->list;
	for(listp1 = context->list; listp1 != NULL; listp1 = listp1->next){
		req_data.mmr_addrs[n] = listp1->item->addr;
		req_data.num_mmrs = ++n;
	}

	error = ioctl(fd, GPC_IOC_READ_REG, &req_data);
	if (error == -1){
		error = 0 - errno;
		goto out;
	}

	i = 0;
	for (listp2 = context->list; listp2 != NULL; listp2 = listp2->next){
		listp2->value = ret_data[i++];
	}

	error = 0;

out:
	if (ret_data)  free(ret_data);
	if (addr_list) free(addr_list);
	close(fd);
	return error;
}




